Cost Based Optimizer in Oracle7

서두

본 지는 비용 중심의 최적화 기능을 채택하는 Oracle7의 질의(query) 최적화 기능을 
다루고자 한다. 비용 최적화 프로그램의 세부 사항이 여기에서 언급된다. 농도
(cardinality), 선택성(selectivity), 결합 순서(join orders)등의 개념 역시 다루
어진다. 이 외에도 실행 계획의 평가시 사용된 비용을 계산하기 위해 이러한 개념들
이 어떻게 사용되어지는가를 본 지에서 다루고 있다. 

비용 최적화 프로그램 기능의 향상은 신기능들을 추가하게 될 것이며, 기존의 기능
들의 효율성 역시 제고될 것이다. 이 후의 Oracle7 릴리즈의 경우, 본 지에서 언급
된 내용중의 일부가 변경될 수 있음을 미리 알려둔다.

질의 최적화(Query Optimization)

질의(query)란 데이터 베이스에 저장된 정보에 대한 비절차적 요청(non-procedural 
request)을 말한다. 질의를 처리하기 위해서 커널(kernel)은 검색 전략을 지정하거
나 후보 행(row)의 페치(fetch)를 위한 실행 계획을 작성해야 한다. 일반적으로 질
의를 실행하기 위한 실행 계획이 여러가지 있기 마련이다. 예를 들어, 결합되는 테
이블 분할(table partitioning)은 커널에서 실행되는 결합 조건, 결합 방법 등에 따
라 각기 다른 순서로 처리된다.

다양한 계획중 하나를 선택하기 위해, 커널은 각 계획에 사용된 리소스(resource)를 
측정하기 위한 현실적인 단위를 반드시 사용해야 한다. 이후, 커널은 다양한 계획중 
비용이 가장 적게 소요되는 계획 하나를 선택하고 이 외의 계획들을 폐기한다.

Version6의 최적화 기능

오라클 사의 Version6는 질의 최적화를 위해 경험적(heuristic) 접근방식을 취하였
다. 실행 계획은 특정한 경험적 접근 방식, 혹은 `규칙'을 기반으로 하여 생성되었
다. 예를 들어, 질의의 `where clause'가 색인된 컬럼을 조회하는 술어(predicate)
를 포함하고 있을 경우, 해당 색인은 이미 설정되어진 색인 순위를 기준으로 한 최
상의 조건을 지닌 색인이 된다. 이 후, 테이블은 그 색인을 사용하여 엑세스되어진
다. 이 때, 테이블의 크기, 해당 컬럼의 데이터의 가변성, 색인의 선택성 등의 기타 
고려 요건들은 무시되었다.

테이블과 색인에 저장되어 있는 데이터에 대한 통계적 설명에 대한 정보는 제공되지 
않았다. 다중 블럭 입출력(I/O) 성능, 사용가능한 정렬(sort) 메모리 등의 인스턴스
(instance) 특정 매개 변수는 고려의 대상에서 제외되었다. 테이블의 데이터가 `규
칙'과 일치하지 않을 경우, 그 다음 순위의 최적화 계획이 생성되었다.


Oracle7의 비용 엔진(Cost Engine)

Oracle7은 비용 요소를 중심으로 실행 계획을 평가하고 선택하기 위해 커널 내부에 
비용 엔진을 탑재함으로써 상기된 기능을 실행한다. 비용은 리소스의 질의 사용 정
도를 양으로 환산한다. 질의에 사용된 리소스는 세 주요 부분으로 분리될 수 있다 - 
입출력 비용, CPU 비용 및 네트워크 비용. 입출력 비용은 디스크로부터 주 메모리로 
이동되는 정보의 전송 비용을 의미한다. 테이블 내의 행은 디스크 파일에 존재하는 
데이터 블럭 내에 저장된다.

행의 엑세스 기능은 주 메모리에 위치하는 공용 전역 영역(Shared Global Area)의 
버퍼 풀(buffer pool) 안으로 블럭을 읽는 기능을 포함한다. 이 기능은 질의 처리 
비용의 핵심 비용이다. CPU 비용은 메모리에서 사용할 수 있는 정보 처리 비용이다. 
블럭이 캐시 메모리에 저장될 경우, 해당 행의 식별 작업이 이루어진후, 결합, 정렬 
등의 기능을 수행하기 위한 프로세스가 실행된다.

분산 데이터 베이스의 노드에 걸쳐 정보를 엑세스하고자 하는 질의의 경우, 정보 이
전 비용(네트워크 입출력)을 측정하는 네트워크 비용이 소요된다. 원거리에 위치하
는 테이블을 엑세스하거나 분산 결합 기능을 수행하고자 하는 질의의 경우, 네트워
크 비용이 대량 소요된다. 최근에 들어와서, 비용 모델은 그 기능들을 입출력 비용 
오퍼레이션 및 CPU 비용과 결합시키고 있다.

네트워크 비용은 직접 연산 방법에 의해 산출되지 않고, 측정된 입출력의 가중치 계
산 방법에 의해 산출된다. 비용 최적화 모델의 성능이 더욱 향상되어감에 따라, 보
다 정확한 비용의 측정과 산출이 이루어지게 될 것이다. 

실행 계획의 비용을 측정하기 위해서는 해당 질의의 객체에 대한 데이터의 상세한 
통계적 설명이 요구되어진다. 이러한 통계 자료는 ANALYZE 기능에 의해 생성된다. 
ANALYZE 기능이 실행되는 모드로는 연산(compute)와 산출(estimate)의 두가지 유형
의 모드가 있다. 연산 모드는 해당 객체의 각 구성요소를 스캐닝(scanning)하는 반
면, 산출 모드는 전체를 대상으로 한다. 통계 자료가 제공되지 않을 경우, 비용 최
적화 프로그램은 하드 코드 방식(hard coded)의 산출방법 혹은 `추정' 방법을 사용
하여야 한다.

최적화 과정

최적화 과정은 질의의 술어에 대한 천이성(transitivity) 분석 기능이 먼저 수행되
어야 한다. 이 후, 각각의 질의 블록은 질의 내의 테이블으로 열려진 경로에 대한 
엑세스 평가에 의해 최적화된다. 결합은 결합 순서 나열 및 비용 산출 과정을 포함
한다. 최적화 프로그램에 다소 영향을 가하기 위해, 사용자는 `힌트'를 지정하여, 
비용 측면과는 상관없이 기타 엑세스 전략들보다 우위에 위치한 특정 엑세스를 우선 
고려대상으로 취급하도록 할 수 있다. 이와 관련된 각 단계는 다음과 같다.

천이성(Transitivity)

테이블 T1과 T2를 포함하는 결합 기능을 수행하는 질의를 다루어보기로 하자.
SELECT ... FROM t1,t2 WHERE
    t1.column1=t2.column1 AND
    t1.column1=100;

위의 질의는 T2상의 술어가 추가된 질의와 동등한 관계에 있다.

SELECT ... FROM t1,t2 WHERE
    t1.column1=t2.column AND
    t1.column1=100 AND
    t2.column1=100;

최적화 기능의 이점은 추가된 술어가 처음의 질의 내부에 존재하지 않았던 
T2.column1
을 위한 추가적인 엑세스 경로를 열어준다는 점이다. 천이성 분석은 객체에게 연결
된 추가적 엑세스 경로를 열기 위해 기존의 술어를 근거로 한 추가적인 술어의 작성 
작업을 포함한다. 하지만, 새로 작성된 경로가 반드시 선택된다는 것을 의미하는 것
은 물론 아니다. 위에서 보듯이 비용 최적화 프로그램은 최적화 과정의 첫 단계로서 
천이적 술어를 생성한다.

농도(Cardinality)

입출력 비용은 질의에 의해 검색,조작되어지는 행의 수와 비례 관계에 있다. 질의는 
테이블의 모든 행을 대상으로 한 검색을 지정하거나, `where clause' 내에 지정되어 
있는 특정 기준을 바탕으로 한 제약조건을 포함할 수 있다. 이 외에도 '그룹별` 절
(節)을 기준으로 하여 결과의 합산(aggregation)을 요구하거나, '명령별' 절을 이용
하여 수식, 컬럼을 대상으로 결과의 정렬(sorting)을 요구할 수 있다. 질의에 의해 
복귀되어질 행의 수가 질의의 농도를 결정한다. 질의의 비용 산출을 가능케하는 비
용 엔진(cost engine)은 질의의 농도를 연산할 수 있는 메케니즘을 반드시 가지고 
있어야 한다.

선택성 분석

농도의 결정시, 선택성 인수가 요구되어진다. 선택성 인수는 컬럼이나 속성값의 특
정 기준을 충족시키는 행의 수에 대한 추정치이다. 일례로, Sex 컬럼과 Female 값을 
충족시키는 모든 행을 검색한다고 가정해 보자. 1/2의 선택성은 해당 행의 절반이 
이 값을 가지고 있음을 의미한다. 일반적으로, `컬럼=상수' 형식의 술어에 대한 선
택성은 다음과 같다.

            Selectivity (of predicate P<n>) = 1/NDV

주(註): NDV는 컬럼의 distinct value의 수치이다. 이 경우, 술어는 `where' 절 조
건만을 나타낸다.

선택성 추정치는 0에서 1의 범위에 이르는 값으로서, 이 중 1은 최저의 선택성을 의
미한다. 술어는 다양한 형식, 관계 연산자(<,> 등), 컬럼 수식, 결합 등의 형태로 
나타난다. 통계적 요소 즉, 고/저 값, distinct value 등의 통계 요소를 사용하고, 
복잡한 형식을 단순 유형으로 바꾸는 과정을 통해, 비용 최적화 프로그램은 각 술어
의 선택성을 계산한다. 


지금까지 술어와 관련된 선택성을 다루었다. 사실상 질의란 불(boolean) 연산자
(`and','or' 및 'not')로 결합된 다수의 술어를 가지기 마련이다. 개별적 술어의 선
택성은 질의의 농도를 결정하기 위해 사용되어지는 전반적인 선택성을 결정하기 위
해 다음과 같이 결합된다.

            Logical Operator               Resultant Selectivity
                AND                               S1 * S2
                 OR                          S1 + S2 - (S1 * S2)
                NOT                                1 - S1

             S1 = Selectivity of Predicate P1
             S2 = Selectivity of Predicate P2


검색 방법

질의의 농도를 계산한 후, 다음으로 고려해야할 요소는 각 검색 방법과 관련된 비용
이다. 최근 오라클 제품이 테이블의 행을 검색하기 위해 사용하는 두 가지 방법은 
다음과 같다.

* 처음 설정된 범위의 첫째 데이터 블록에서부터 할당된 최후의 블록까지 순서적으
로 테이블을 스캐닝하는 방법을 `전역 테이블 스캔'이라 한다.
* 하나 이상의 색인을 대상으로 한 룩업(lookup)을 실행하여 해당 행의 주소를 검색
하는 기능을 이용하여 한 번에 하나의 테이블 블록을 엑세스하는 방법을 `색인 스캔
'이라 한다.

각 방법은 입출력 작업을 요구한다. 캐시 메모리 내부의 블록의 가용성 여부에 대한 
어떠한 예측 기능도 존재하지 않는다. 각 경우에 해당하는 입출력은 엑세스된 객체 
및 특정 초기화 매개변수(다중 블록 읽기 인수)의 통계적 설명자를 통해 세부화되어
진다. 

테이블은 다수의 색인 엑세스를 가질 수 있다. 질의의 경우, 하나 이상의 색인을 사
용할 수 있다. 비용 엔진은 사용가능한 모든 엑세스 경로를 고려하여 각 경로의 비
용을 계산한다.

전역 스캔 비용

전역 테이블 스캔 비용은 테이블에 의해 사용된 모든 블록과 다중 블록 읽기 인수의 
최대치에 좌우된다. 테이블 내부로 삽입되는 행의 수가 증가할 경우, 테이블에 할당
된 익스텐트(변수의 존속범위)를 기준으로 블록이 설정된다. 테이블 상의 몇몇 행들
이 이후에 삭제되어 블록이 비게 될 경우에도 커널은 테이블에 의해 사용된 모든 블
록을 읽을 수 있다. 다중 블록 읽기 인수는 단일 입출력 작업으로 읽을 수 있는 근
접 데이터 베이스 블록의 수를 의미한다.






색인 스캔 비용

색인된 엑세스의 사용 비용은 아래의 두 가지 구성요소로 나뉘어질 수 있다.

* 색인 주사(走査) 비용(오라클 색인은 가지 블록 및 나뭇잎 블록의 하나 이상의 레
벨로 구성된 B*트리이다.)
* 테이블 룩업 기능 수행비. 최적화 프로그램이 색인 룩업이 질의 요건을 충족시키
는데 충분하다고 판단을 내린 경우 등 몇몇의 경우, 필요없다.

다음의 통계적 설명자는 색인과 관련하여 사용될 수 있다.
* B1 - 나뭇잎 레벨을 포함한 색인 레벨의 수
* Lb - 나뭇잎 블록 수
* Bk - 각각의 색인 주요 값에 해당하는 색인 나뭇잎 블록의 평균치
* Dk - 주요 키 값에 의해 지정된 테이블 내의 데이터 블록의 평균치
* Cf - 클러스터 인수

이 값은 색인 값들을 기반으로 한 테이블 블록 내의 행의 순서를 지시한다. 만일 이 
값이 해당 테이블 내의 블록의 수에 근접할 경우, 테이블 행은 이 색인의 값들에 의
해 순서가 결정된다. 이 경우, 색인 나뭇잎 블록 내의 행 주소들이 동일한 테이블 
데이터 블록 내의 행을 지시할 가능성이 가장 높다. 만일 이 값이 해당 테이블 내의 
행의 수에 근접할 경우, 테이블 행은 이 색인의 값과 밀접한 관계를 유지한 채, 랜
덤(random)하게 분산된다. 이 경우, 행의 주소들은 각기 다른 테이블 데이터 블록 
내의 행을 지시할 가능성이 가장 높다. 

색인 주사(走査) 비용은 하나 이상의 설명자를 사용하여 계산된다. 예를 들어, 고유
(unique) 색인의 모든 컬럼을 대상으로 `column=<constant>' 형식의 술어를 가지고 
있는 질의를 생각해 보자.

           색인 엑세스 비용 = 레벨의 수 + 1 = B1 =+ 1

다른 말로 표현하자면, 색인 엑세스 비용은 우리가 인덱스를 주사할 때 각 블록을 
엑세스하는 비용과 테이블 블럭의 엑세스 비용이라 할 수 있다. 비용 엔진은 복잡한 
사례의 비용을 평가하기 위해 다수의 인수를 사용한다. 술어는 `column>value' 등의 
부등식 연산자 혹은 'LIKE` 연산자를 사용하거나, 연결된 색인 내의 특정 컬럼들을 
지정할 수 있다. 선택성 추정치 및 테이블/색인 통계치를 사용하여, 비용 엔진은 술
어에 의해 영항을 받게 될 블록의 수를 계산하여 해당 비용을 산출해낸다.

정렬 비용

특정 SQL 처리는 열의 정렬 기능을 필요로 할 경우가 있다. `명령별',`그룹별' 절이 
명시적으로 사용되는 경우처럼 SQL 명령문 내에서 명시적으로 실행되는 경우도 있
고, 정렬 병합(merge) 결합이 두 개의 테이블을 결합하는 경우와 같이 암묵적으로 
실행되는 경우도 있다. 정렬 기능을 수행하기 위해 그 어느 것이 정렬 기능을 트리
거하는 지의 여부에 상관없이, 커널은 비용 산출이 요구되는 시스템 자원을 사용한
다. 데이터의 정렬 방법에 따라, 커널은 메모리 내에서 정렬 기능을 완료시킨다. 이 
기능은 초기화 매개변수 `sort_area_size'의 설정 여부에 달려있다. 만일 정렬 대상
인 데이터가 'sort_area_size' 버퍼에 들어맞지 않을 경우, 커널은 정렬을 관리가능
한 세그먼트로 나누어, 임시 세그먼트라 불리우는 디스크 영역에 결과를 작성하는 
정렬 기능을 수행한다.

모든 세그먼트가 정렬된 후, 최종 병합 패스(final merge pass)를 처리해야 한다. 
정렬 입출력 비용의 산출시, 행의 평균 길이를 바탕으로 한 데이터 크기를 우선적으
로 결정해야 한다. 이 때, 사용자는 sort_area_size에 적합한지 적합하지 않은지를 
확인할 수 있다. 만일 적합하다면, 입출력은 필요치않을 것이고, 적합하지 않다면, 
입출력은 임시 세그먼트의 기록/읽기에 따라 입출력이 산출된다. 다중 블록 입출력 
성능 역시 계산 과정의 고려 요소라 할 수 있다. 비용 계산은 최종 병합 패스 과정
에서 수행된 작업을 고려의 대상에 포함한다. 

결합 처리

하나 이상의 테이블을 대상으로 한 질의의 경우, 결합 처리는 결합 기능을 수행하기 
위한 최적 계획을 결정해야 한다. 여기에는 다음과 같은 요소가 포함되어 있다.
* 결합 농도
* 결합 순서 열거
* 각 결합 방법이 사용하는 결합 경로에 해당하는 비용 평가

결합 농도

결합 농도는 결합 관계를 구성하는 행의 수를 의미한다. 최악의 경우, 결합 술어가 
존재하지 않을 경우가 있으며, 둘 이상의 테이블을 대상으로 하는 카테션의 곱
(cartesian product)이 농도가 되는 경우도 있다. 일반적으로, 둘 이상의 테이블이 
결합될 때, 이 결합은 몇몇 컬럼의 값들에 좌우된다. 컬럼 상의 통계적 설명자와 각 
테이블 내의 행의 수를 사용하여, 우리는 결합된 형식의 농도를 계산할 수 있다.

결합 순서

`결합 순서'는 결합 관계를 완료하기 위해 결합되어질 테이블을 엑세스하는 순서의 
순열을 의미한다. 결합 순서는 결합의 유형 및 결합 토폴로지에 따라 좌우된다. 결
합 술어의 구조에 











따라, 결합은 고리, 별, 원, 그래프 등의 다양한 유형으로 분류된다. 예를 들어, 세 
개의 테이블을 대상으로 한 질의를 생각해보자.

                 SELECT ... FROM t1,t2,t3 WHERE
                   t1.coll = t2.coll AND
                   t2.coll = t3.coll;

테이블 t1,t2,t3는 고리형 결합을 이루고 있다. 이 경우, 유효 순열은 4이고, 일반
적인 고리 결합의 경우, (2) 제곱 (n-1), (단, n= 테이블의 수)이다.

가능한 결합 순서 : t1->t2->t3, t2->t1->t3, t2->t3->t1, t3->t2->t1

리소스 사용과 관련하여 각 결합 순서의 평가가 필요하다. 테이블의 수가 증가할 경
우, 결합 토폴로지에 따라 검색 공간 혹은 순열이 대폭 증가하게 된다. 검색 공간의 
전지 작업(pruning) 및 최상의 결합 순서를 식별하기 위한 작업량의 감소를 위해 다
양한 방법들이 사용된다.

결합 경로 비용 평가

각 결합 순서마다 최적화 프로그램은 순서를 한 쌍(pair)씩 분리함으로써, 결합 기
능의 수행 비용을 평가한다. 첫 부분은 이미 결합된 관계들로 구성되고, 두번째 부
분은 결합될 다음 테이블로 구성된다. 현재 커널 내부에서 실행되고 있는 결합 방법
인 정렬-병합 결합 방법과 내포형 루프(nested-loops) 결합 방법을 사용하여 비용 
평가가 이루어진다.

정렬-병합 방법의 경우, 결합 대상인 테이블은 결합 컬럼들에 의해 우선적으로 정렬
된다. 이 후, 정렬된 관계들은 결합되어진다. 이 방법을 사용하는 결합 수행 비용은 
정렬 비용과 결합을 수행하기 위해 정렬된 기록을 검색하는 비용을 포함하고 있다.

내포형 루프 방법의 경우, 한 번에 외부 테이블 행 하나를 스캔할 수 있고, 검색된 
각 행을 대상으로 결합 컬럼을 기반으로 한 내부 테이블을 엑세스할 수 있다. 외부 
테이블은 실제적으로 두 개 이상의 테이블이 결합되어 있는 결합 관계가 된다. 이 
방법을 사용하는 결합 수행 비용은 외부 테이블 및 각각의 검색 행을 엑세스하는 비
용과 결합 컬럼을 기반으로 내부 테이블의 행 그룹을 대응(match)시키는 비용을 포
함하고 있다.

특정 결합 순서의 테이블의 경우, 수많은 사용가능한 엑세스 경로가 있기 마련이다. 
해당 테이블은 ROWID를 사용하여 엑세스되거나, 테이블 스캔을 통해 엑세스될 수 있
다. 이 외에도 단일 색인, 클러스터 스캔, 단일 색인의 비(非)고유 색인 등을 사용
하여 테이블을 엑세스하는 방법도 있다. 엑세스 경로 선택 작업의 속도를 증가하기 
위해 검색 공간을 줄이거나 전지(pruning)하기 위해 다양한 방법들이 사용된다. 일
례로, ROWID의 룩업이 있을 경우, 해당 엑세스 경로는 최상의 것으로 간주되며, 따
라서 사용자는 여타 엑세스 경로를 굳이 평가하고자 하는 노력을 기울이지 않아도 
된다.

실행 계획의 선택

최적화 프로그램은 각 계획의 비용을 평가할 때, 현 단계까지 획득한 최상의 계획 
비용과 해당 계획 비용을 비교하는 방식을 채택한다. 최적화 프로그램은 지정된 범
위내에서 최상의 계획을 찾을 때까지 이러한 비교 작업을 반복한다. 하지만, 사용자
가 자신의 데이터 지식을 바탕으로 선택된 최상의 계획이 이상적이지 않다는 판단을 
내릴 경우, 사용자는 `힌트'를 사용하여 다른 계획을 실행시킬 수 있다.

비용 최적화 프로그램에게 영향력을 행사하는 힌트

버전 6의 경우, 최적화 프로그램은 다양한 방법에 의해 영향을 받는다. 질의는 특정 
결합 순서를 실행하기 위해 다른 순서로 지정된 테이블들과 재배열될 수 있고, 함수
들은 색인된 컬럼 주위에 배치되어 색인 사용을 피하는 방법 등 다양하다. 이러한 
기술들은 상당 시간에 걸쳐 사용자들에 의해 개발되었으며, 사용자가 원하는 성능을 
실행하기 위해 필요한 중요한 기술들이다. 하지만, 이러한 기술의 서류화 및 일반화 
작업이 어렵다는 문제점이 남아있다. 이러한 어려움을 해결하기 위해, 비용 최적화 
프로그램은 최상의 결과를 창출하지 못할 경우, 사용자가 직접 최적화 프로그램의 
행동양식을 결정할 수 있는 메커니즘을 채택하고 있다. 사용자는 엑세스 방법, 결합 
처리 기술, 결합 순서 등의 지시문을 힌트를 통해 지정할 수 있다.

힌트는 다수의 플랫폼 상에서 자유로이 이식될 수 있도록 SQL 명령문의 주석에 지정
되어 있다. 술어에서 참조되지 않은 컬럼의 색인을 참조하는 등 무효 힌트는 무시된
다. 몇몇의 경우, 예를 들어 뷰 최적화 기능이 수행되어 뷰의 질의가 기저 테이블 
내부로 병합되어, 뷰를 대상으로 지정된 힌트가 사용되지 않을 경우 등 몇몇의 경
우, 힌트가 없어질 수 있다.

비용 최적화 프로그램은 디폴트 기능을 통해, 질의에 의해 페치(fetch)되어질 모든 
행의 검색 기능에 소요되는 전체 비용을 절감하기 위해 질의를 최적화하고자 한다. 
질의 최적화 기능은 SQL*Forms 등의 상호작용 애플리케이션을 실행하는 사용자가 첫
째 행을 최적화하고자 하는 경우와 같은 몇몇 사례 아래 변경될 수 있다. 최적화 기
능은 `alter session set optimizer_goal' 명령문을 사용하여 최적화 기능 수행을 
위한 세션 레벨 목표를 설정한 후 실행된다. 비용 최적화 프로그램은 모든 행의 비
용을 질의의 농도로 나눔으로써, 비용을 재평가한다. 이러한 기능은 색인된 스캔이
나 내포형 루프 등의 특정 오퍼레이션을 여타 엑세스 방법들과 비교해볼 때 우위적
인 기능으로 만들어준다.

요약

비용 최적화 처리는 Oracle7의 주요 확장 기능이다. Oracle8이 출시될 즈음하여 규
칙을 기반으로 하는 접근 방식은 소멸되리라 추측된다. 비용 최적화 프로그램의 기
존의 기능성은 향상되어 왔고, 앞으로 더욱 첨단 기능으로 개발되어 갈 것이며, 거
의 모든 상황 아래 지능 기능을 수행할 것이다. 사용자가 원하는 성능이 실현되지 
않고 더 나은 엑세스 전략이 존재하는 경우, 사용자는 힌트를 사용하여 특정 계획을 
실행할 수 있다.





