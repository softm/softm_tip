# top 명령어를 이용해서 확인할 수 있는정보 ( Memory )
    # used memory가 많이 잡혔다고해서 모두 소진되고 있는것이 아님.
      리눅스 시스템 특성상 memory를 캐쉬해놓고 효율을 올리는 방식을 사용한다고함.
        # 실제 freeMemory size : buffers + cached
    # swap의 used가 사용되기 시작하면 memory 부하를 의심해볼수 있음

    top - 18:09:58 up 284 days, 16:01,  3 users,  load average: 0.51, 0.20, 0.13
    Tasks:  75 total,   1 running,  72 sleeping,   2 stopped,   0 zombie
    Cpu(s):  1.0% us,  0.5% sy,  0.0% ni, 98.4% id,  0.1% wa,  0.0% hi,  0.0% si
    Mem:   4154044k total,  4091000k used,    63044k free,   129668k buffers
    Swap:  1020116k total,      124k used,  1019992k free,  3068532k cached

      PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
     9052 root      18   0 1596m 740m 6072 S    2 18.3 422:46.29 java
        1 root      15   0  2432  548  472 S    0  0.0   5:42.05 init
        2 root      RT   0     0    0    0 S    0  0.0   0:12.19 migration/0
        3 root      34  19     0    0    0 S    0  0.0   0:10.09 ksoftirqd/0
        4 root      RT   0     0    0    0 S    0  0.0   0:02.58 migration/1
        5 root      34  19     0    0    0 S    0  0.0   0:02.79 ksoftirqd/1
        6 root       5 -10     0    0    0 S    0  0.0   0:00.99 events/0
        7 root       5 -10     0    0    0 S    0  0.0   0:12.15 events/1

# vmstat 1 ( CPU )
    소개
        시스템은 충분한 실제 메모리를 가지고 있슴에도 불구하고， 논리적 자원들이 적절하게 할당되어 있지 않기 때문에 원하는 성능이 나오지 않는 경우도 있다．
        vmstat(1) 를 이용하여 실제 자원과 논리적 자원의 활용도를 확인할 수 있다． 이 명령은 커널 테이블과 카운터들(2) 의 자료를 샘플수집하여， 그 결과를 평준화시킨 후 이를 적절한 형식에 따라 보여 준다．

        기본적으로는 vmstat 는 그 결과를 표준출력으로 보내며， 이는 다른 곳으로 보내질 수도 있다．

    vmstat 명령에 대한 설명
        vmstat 는 기간과 측정하는 회수를 지정하여 실행된다． 여기서 기간이란 vmstat 가 자료를 수집하고 보고하는 시간의 차이를 초단위로 표시한 것이며， 회수는 이러한 보고를 몇번 수행할 것인가를 뜻하는 것이다． 만일 아무런 변수를 지정하지 않고 vmstat 를 사용하는 경우에는， vmstat 는 시스템이 기동된 이후부터의 누적된 통계자료를 하나의 레코드로 보여 준다． 즉 시스템이 비활동적인 경우도 있고， 업무부하의 변동이 있었기 때문에， 이 자료는 실제 시스템의 현재 활동내역을 보여주지는 않는다． vmstat 를 사용시 출력되는 보고내용의 첫번째 줄은 시스템이 기동된 이후의 누적통계를 보여주는 것임을 명심하여야 한다．（물론 -f 혹은 -s 옵션을 사용하지 않은 경우이다） 따라서 대부분의 경우에 있어， 이를 무시하여도 된다．
        vmstat 는 프로세스들과 가상메모리， 페이징 활동， 페이징 실패(3) ， CPU 활동및 디스크들의 자료전송에 대한 통계를 제공한다．
        이 명령의 사용방법은 다음과 같다:
         vmstat -fs Drives Interval Count

    Figure 1. "vmstat 1 3"의 출력 결과 예

     procs memory page faults cpu
     ----- -------- ----------------- -------------- -----------
     r b avm fre re pi po fr sr cy in sy cs us sy id wa
     0 0 6747 1253 0 0 0 0 0 0 114 10 22 0 1 26 0
     1 0 6747 1253 0 0 0 0 0 0 113 118 43 17 4 79 0
     0 0 6747 1253 0 0 0 0 0 0 118 99 33 8 3 89 0


    다음은 Figure 1의 각 항목들에 대한 설명이다．

    procs
     "procs" 아래의 내용은 여러 큐들에 놓여 있는 프로세스들의 평균 수에 관련한 정보를 제공한다．

     r
     "r" 에 표시된 숫자는 1 초간격으로 실행 큐에 놓여 있는 프로세스들의 평균 수를 나타낸다．
     이 값은 ＂실행가능한＂ 프로세스들의 수이다． 시스템은 매초마다 실행준비가 된(4) 프로세스들의 수를 확인하여， 이를 내부 카운터에 더한다． vmstat 는 최종값에서 이 카운터의 최초 값을 빼고， 이 값을 측정기간만큼의 초로 나눈다． 안정된 업무부하의 상태에서는 이 값은 5 보다 적은 것이 일반적이다． 만일 이 값이 급격히 증가하게 되면， 어플리케이션에 어떤 문제가 있는지를 확인하여야 한다． 만일 CPU 자원을 요구하는 많은 프로세스들（특히 CPU 중심적인 작업들）이 있는 경우에는， 이들 프로세스들은 라운드－로빈(5) 방식에 의해 실행된다． 각각의 프로세스들이 주어진 시간동안 쉬지 않고 실행되는 경우에는， 이 값은 쉽게 100 을 넘게 될 수도 있다．

     b
     "b" 에 표시된 숫자는 1 초간격으로 대기 큐에 놓여 있는 프로세스들의 평균 수를 나타낸다．
     대기 큐에 놓여 있는 프로세스들은 자신들의 프로세스 페이지중의 하나가 페이지인(6) 되어 실행되기를 기다린다． 매초마다 시스템은 대기중인 프로세스들의 수를 확인하여 이를 내부 카운터에 더한다． vmstat 는 이후 최종 값에서 최초 값을 빼고， 이를 측정기간의 초로 나눈다． 보통 이 값은 0 이다． 물론 여기서 이 값과 입출력을 기다리고 있슴을 나타내는 "wa"와 혼동하여서는 않된다．

    memory
     "memory" 에 표시된 정보는 실제 메모리와 가상 메모리에 대한 정보를 제공한다．

     avm
     "avm" 에 표신된 숫자는 페이징 공간에 할당된 평균 페이지들의 수를 보여준다．（AIX 에서는 각 페이지들은 4,096 바이트의 크기를 가진다）

     한 프로세스가 실행될 경우에는， 작업공간이 페이징 디바이스（들）에 할당된다．(이를 backing store된다고 한다） 이는 실행중인 프로세스들에 대하여 할당되어 있는 페이징 공간의 양을 계산하는데 사용되기도 한다． "avm" 에 표시된 수를 256 으로 나누면， 이는 시스템 전체에 할당된 페이징 공간을 메가바이트로 나타낸 수가 된다． "lsps -a" 명령을 사용하면， 각각 페이징 공간의 크기를 확인할 수 있다． 물론 이러한 페이징 공간의 사용정도가 100 % 에 가까운 값을 갖지 않도록， 충분한 페이징 공간을 시스템에 할당하여야 하는 것은 매우 중요한 일이다． 만일 할당되지 않은 페이지들의 수가 128 보다 작은 경우에는 시스템은 충분한 페이징 공간을 확보하기 위하여 프로세스들을 죽이기 시작한다．

     fre
     "fre" 에 표시된 숫자는 할당되지 않은 메모리 프레임들(7) 의 평균 수를 나타낸다． 한 프레임이란 한 프레임이란 4,096 바이트의 실제 메모리이다．

     시스템은 자유명세서(8) 라 하는 메모리 프레임들의 버퍼를 관리한다． 이는 가상 메모리 관리자(9) 가 공간을 필요로 하는 경우에 사용된다． 적정한 자유명세서의 크기는 설치된 실제 메모리의 크기에 따라 변하게 된다． 64 MB 이상의 메모리가 설치되어 있는 시스템에서는， 최소한의 값（MINFREE）은 120 프레임이다． 64 MB 보다 적은 메모리를 가진 시스템은， 이 값은 실제 메모리의 크기의 두배의 값에서 8 을 뺀 값이다． 예를 들어， 32 MB 의 메모리를 가진 시스템에서는， MINFREE 의 값은 56 이다．

     만일 fre 값인 MAXFREE 값（이는 MINFREE 의 값에 8 을 더하여 얻어진다）을 넘어서게 되는 경우에는， 시스템은 스래싱을 일으키지 않는 것으로 판단된다．(10) 만일 시스템이 스래싱을 일으키고 있는 경우에는， fre 값이 적다고 판단하여도 된다． 대부분의 유닉스와 AIX 운영체계에서는， 대분분의 가용할 수 있는 실제 메모리들을 디스크 캐쉬로 사용하기 때문에， 이 fre 값이 MINFREE 와 MAXFREE 사이에서 왔다갔다하는 경우에는 크게 걱정하지 않아도 된다．

    page
     "page" 에 표시된 정보는 페이지 실패및 페이징 활동에 대한 정보를 제공한다．

     re
     "re" 에 표시된 값은 재요청(11) 된 페이지들의 수（정도）를 나타낸다．

     재요청된 페이지들은， 해당 페이지들이 아직도 메모리내에 있기 때문에， 새로운 입출력 요청을 하지 않고도 주소번역실패(12) 를 충족시킬 수 있다． 이는 자유명세서에 놓여져 있스면서 재할당되지 않은 상태에서 다시 사용요청된 페이지들을 포함한다． 이는 VMM 에 의해 이미 요청되었스면서 입출력이 아직 완료되지 않은 페이지들과 VMM 의 readahead 메카니즘에 의해 미리 선정되었스면서 실패된 세그먼트(13) 로부터 숨겨져 있는 페이지들을 포함한다．

     pi
     "pi" 줄은 페이징 공간에서 메모리로 들어온 페이지들(14) 의 수를 보여준다．

     페이징 공간은 디스크상에 놓여 있는 가상 메모리의 한 부분이다． 이는 메모리가 너무 많이 요청된 경우에 ＂넘치는 부분（overflow）＂을 위해 사용된다． 페이징이란 실제 메모리로부터 훔쳐진 작업 묶음 페이지들(15) 의 저장공간으로 할당된 페이징 논리적 볼륨들(16) 로 구성된다． 만일 이렇게 훔쳐진 페이지들을 프로세스가 참조하는 경우에는， 페이지 실패(17) 가 발생하게 되고， 이 페이지는 페이징 공간으로부터 메모리로 읽혀져 들어와야만 한다． 이값이 얼마이면 좋은가하는 지침은 없는데， 이는 하드웨어， 소프트웨어및 어플리케이션들의 구성에 의존하는 정도가 크기 때문이다．

     몇몇 분석가들은 초당 5개의 페이지－인 정도가 최대 한계라고 말하곤 한다． 이러한 이론적인 최대값을 반드시 따를 필요는 없지만， 참조값으로는 사용할 수 있다． 이 값은 페이징 공간의 활동을 알려주는 매우 중요한 값이다． 이를 다음과 같이 이해하도록 한다: 만일 하나의 페이지－인(18) 이 발생하면， 이 페이지에 대한 전의 페이지－아웃(19) 이 반드시 있었다는 것이다． 이러한 현상은 각각의 페이지－인들이 다른 페이지들을 훔치게 하여， 결과적으로는 페이지 아웃을 초래하게 되는 메모리 제약 환경(20) 내에서 발생하기 쉽다는 것이다．

     po
     "po" 에 표시된 값들은 메모리로부터 페이징 공간으로 축출된 페이지들(21) 의 수（정도）를 나타낸다．

     작업공간(22) 의 한 페이지가 훔쳐지게 되면， 이는 페이징 공간에 쓰여진다． 만일 다시 참조되지 않으면， 이는 해당 프로세스가 종료되거나 그 공간이 취소될때까지 그 페이징 공간에 남아 있는다． 쫓겨난 페이지들내에 포함된 주소를 후에 참조하게 되면 이는 페이지 실패(23) 들을 야기시키고， 해당 페이지들은 시스템에 의해 개별적으로 메모리로 들어오게 된다． 만일 한 프로세스가 정상적으로 종료되면， 그 프로세스에 대하여 할당되었던 모든 페이징 공간들은 자유롭게 된다． 만일 시스템이 지속적인 페이지들(24) 을 중점적으로 읽게 되는 경우에는， "pi" 의 값은 증가하지 않으면서， "po" 의 값이 증가되는 것을 확인할 수 있을 것이다． 이는 스래싱(25) 을 나타내지는 않지만， 해당 어플리케이션（들）의 자료사용방식(26) 을 확인할 필요가 있다는 경고일수도 있다．

     fr
     "fr" 은 자유롭게 되는 페이지들의 수（정도）를 나타낸다． 이를 자유화율이라 한다．

     VMM 페이지－교체 코드(27) 는 페이지 프레임 테이블(PFT(28) )을 살피게 되는데， 이는 가용한 메모리 프레임들의 자유명세서를 새로 보충하기 위하여 어떤 페이지들을 훔칠 것인가를 선택하기 위한 특정 기준을 사용한다． VMM에 의해 훔쳐진 전체 페이지들－작업（계산적） 페이지들과 파일（지속적） 페이지들－이 매초당 비율로써 보고된다． 한 페이지가 자유롭게 되었다는 것만으로는， 실제 입출력이 발생하였다는 것을 뜻하지는 않는다． 예를 들면， 한 지속적 저장（파일） 페이지가 수정되기 전까지는， 이는 실제로 디스크에 쓰여지지는 않는다． 즉 입출력이 필요하지 않은 경우에는， 한 페이지를 자유롭게 하기 위하여 최소한의 시스템 자원만이 요청되게 된다．

     sr
     "sr" 줄에 표시된 수는 페이지－교체 알고리즘에 의해 조회된 페이지들의 수（정도）이다． 이를 조회율이라 한다．

     VMM 페이지－교체 코드는 PFT를 조회하고 자유명세서상의 프레임들의 수가 MAXFREE 값에 이를때까지 계속하여 페이지들을 훔치게 된다． 페이지－교체 코드는 자유명세서의 요건을 만족할 때까지 페이지를 훔치기 전에 PFT내의 많은 항목들을 조회하여야만 한다． 안정적이고 조각화되지 않은 메모리인 경우에는， 조회율과 자유화율이 아마 비슷할 것이다． 여러 프로세스들이 서로 다른 페이지들을 사용하는 시스템상에서는， 이들 페이지들은 매우 활성적이고 또 서로 연관이 없는 경우가 많다． 이러한 경우에는， 조회율은 자유화율을 훨씬 웃도는 경우가 많다．

     cy
     "cy" 줄에 표시된 수는 페이지 프레임 테이블을 완전히 조회한 정도를 표시한다．

     "cy" 의 값은 페이지－교체 코드가 페이지 프레임 테이블을 초당 몇번이나 조회하였는가를 나타낸다． 자유명세서는 PFT 를 완전히 조회하지 않고도 계속 보충될 수 있스며 또한 vmstat 명령을 이용하여 조회되는 값들은 모두 정수이므로， 이 값은 주로 0 인 경우가 일반적이다．

    faults
     "faults" 아래에 표시된 정보는 프로세스 통제에 관련한 정보를 나타낸다．

     in
     "in" 에 표시된 값은 디바이스 인터럽트의 수（정도）를 보여준다．

     여기에 표시된 값은 측정기간내에 관측된 하드웨어나 혹은 디바이스 인터럽트의 초당 수이다． 이러한 인터럽트들의 예는 디스크 요청의 완료와 1/100 초 단위의 시계 인터럽트이다． 후자는 초당 100 번 발생하기 때문에 이 값은 항상 100 보다 크다．

     sy
     "sy" 줄에 표시된 값은 시스템 호출들의 수（정도）를 표시한다．

     사용자 프로세스들은 잘 정의된 시스템 호출들을 이용하여 자원들을 사용할 수 있다． 이들 호출들은 커널로 하여금 호출 프로세스에 대한 작업을 하도록 하며， 커널과 프로세스간의 자료교환을 가능하게 하여 준다． 업무부하와 어플리케이션들에 따라 매우 다른 호출들이 서로 다른 기능들을 수행하기 때문에， 초당 발생할 수 있는 시스템 호출들의 적정 수를 언급하기란 매우 어려운 일이다．

     cs
     "cs" 에 표시된 값들은 콘텍스트 교환(29) 의 수（정도）를 나타낸다．

     물리적인 CPU 자원은 각각 1/100 단위의 논리적 시간 조각으로 나누어 진다． 만일 한 프로세스가 실행을 위해 스케쥴 된 경우에는， 이는 자신에게 할당된 한 단위의 시간만큼 실행된 후 실행을 중지하거나， 혹은 한 단위의 시간을 채우지 않고도 자신이 바라는 대로 CPU 사용을 중지하게 된다． 만일 다른 프로세스에게 CPU 사용이 주어지는 경우에는， 이전 프로세스의 콘텍스트 혹은 작업환경은 반드시 보관되어야 하며， 현재 프로세스의 콘텍스트가 로드되어야 한다． AIX는 매유 효율적인 콘텍스트 교환 절차를 가지고 있기 때문에， 각각의 교환는 자원의 활용적인 측면에 있어 아주 효과적이라고 할 수 있다． 하지만 콘텍스트 교환의 수가 급격히 층가하는 경우에는， 추가적인 조사를 하여야 할 것이다．

    CPU
     "cpu" 아래의 정보들은 CPU 사용을 구분하여 보여 준다．

     us
     "us" 줄의 값은 사용자 모드에서 소비된 CPU 시간의 백분율을 보여 준다．

     프로세스들은 사용자 모드 혹은 시스템（커널） 모드에서 운영된다． 사용자 모드에 있는 경우에는， 한 프로세스는 자신의 코드내에서만 실행되고， 계산을 실행하거나 혹은 메모리를 관리하거나 혹은 변수들을 설정하는데 있어 커널 자원들을 필요로 하지 않는다．

     sy
     "sy" 줄의 값은 시스템 모드에서 소비된 CPU 시간의 백분율을 보여 준다．

     만일 어떤 프로세스가 커널 자원을 필요로 하는 경우에는， 이는 반드시 시스템 호출을 실행하여 해당 자원을 사용할 수 있는 시스템 모드 상태로 돌입하여야 한다． 예를 들면 드라이버에 대한 입출력은 해당 장치를 열고， 찾고， 자료를 읽고 쓰기 위한 호출을 실행하여야만 한다． 이 값은 CPU 가 시스템 모드에 놓여 있었던 시간의 백분율을 보여 준다． 최적의 사용은 CPU 가 해당 시간의 100 퍼센트를 사용할 것이다． 이는 CPU 를 공유할 필요가 없는 단일사용자 시스템의 경우는 맞다고 할 수 있다． 일반적으로는 사용자＋시스템 시간이 90 퍼센트보다 작은 경우에는， 그 단일사용자 시스템은 CPU 가 부족하다고 할 수 없다． 하지만， 다중사용자 시스템의 경우에 있어서는 사용자＋시스템 시간이 80 퍼센트가 넘는 경우에는， 프로세스들이 실행 큐에서 대기하는데 시간을 소비한다고 할 수 있다． 따라서 응답시간및 처리속도는 저하될 것이다．

     id
     "id" 줄의 값은 지연된 디스크 입출력이 없는 상태에서 CPU가 놀고 있는 시간（백분율）을 보여 준다．

     만일 실행가능한 프로세스가 없는 경우（실행 큐가 비어 있는 경우）， 시스템은 웨이트(wait)라하는 프로세스를 연결한다． ps -k（혹은 g）의 보고서는 이를 514 의 프로세스 ID(PID)(30) 를 가지는 kproc 으로 구분한다． 만일 ps 보고서의 내용이 이 프로세스에 대한 매우 큰 축적된 시간을 보이더라도 걱정할 필요는 없다．(31) 이는 아무런 프로세스도 운영되지 않으면서 많은 시간을 보냈다는 것을 의미하는 것이다． 만일 자신의 디스크에 지연된 입출력이 없는 경우에는， "wait"에 기인한 모든 시간들이 idle 시간으로 구분된다．

     wa
     "wa" 줄의 값은 지연된 디스크 입출력이 있는 상태에서 CPU가 놀고 있는 시간（백분율）을 보여 준다．

     만일 "wait" 가 실행되는 중에， 자신의 디스크에 대한 최소한 하나의 중요한 입출력인 있는 경우에는， 이 시간은 ”입출력을 기다리는 시간”으로 구분된다． 40 퍼센트를 상회하는 wa 값은 해당 디스크 부시스템에 부적절하게 구성되어 있거나， 혹은 디스크 중심적인 작업부하의 결과라고 할 수 있다． 만일 하나의 프로세스만이 실행가능한 경우－이는 기술적인 업무의 경우에 흔히 발생한다－에는， 이러한 입출력의 대기를 피하는 방법이 없을 수도 있다．

    요약 통계

    -s 옵션을 지정한 vmstat 는 시스템이 기동된 이후의 여러 사건들의 절대값들을 제공한다． "vmstat -s" 의 출력자료내에는 총 23 개의 각각 사건들이 있다; 이중 다음의 4 가지 내용이 도움이 될 것이다． 나머지 19 개의 필드들은 주소번역실패(32) 로부터 시스템 호출에 대한 잠금 착오(33) 에 이르기까지의 여러 활동들을 포함한다． 이들 19 가지의 내용도 역시 그 나름대로의 가치가 있지만， 자주 사용되지는 않는다．

    page ins
     "page ins" 필드의 값은 시스템 전체의 page-ins의 수를 보여 준다．

     한 페이지가 디스크에서 메모리로 읽혀질 때에， 이 값은 하나가 증가한다． 이는 page outs 필드와 함께 VMM에 의한 읽기 동작의 수이며， VMM에 의해 기동된 실제 입출력（디스크의 읽기와 쓰기）를 나타낸다．
     "page outs" 필드의 값은 시스템 전체의 page-outs의 수를 보여 준다．

     하나의 페이지가 디스크로 쓰여질 때마다， 이 값이 증가된다． 이는 page ins 필드와 함께 VMM 에 의한 쓰기 동작의 전체 수이며， 이는 VMM 에 의해 기동된 실제 입출력의 전체 양을 나타낸다．

    paging space page ins
     "paging space page ins" 필드의 값은 페이징 공간으로부터 읽은 페이지들의 수만을 나타낸다．

    paging space page outs
     "paging space page outs" 필드의 값은 페이징 공간으로 쓰여진 페이지들의 수만을 나타낸다．

    요약 통계의 사용

    위에서 설명한 네 필드들은 지속적 스토리지에 대하여 얼마만큼의 시스템 입출력이 있었는가를 나타내는제 사용된다． 만일 page ins에 대한 시스템 전체의 값에서 페이징 공간의 page ins 을 빼면， 이 값은 지속적 스토리지（파일）으로부터 읽혀진 페이지들의 수를 나타내는 것이다． 유사한 방법으로 page outs에 대한 시스템 전체의 값에서 페이징 공간의 page outs의 값을 빼게 되면， 그 결과는 디스크에 쓰여지는 지속적 페이지들（파일）의 수가 될 것이다．

    이 값들은 시스템 기동후부터의 누적된 값이라는 것을 명심하도록 한다． 만일 주어지 기간동안의 값들이 필요한 경우에는， "vmstat -s" 를 관측을 시작하는 시점과 끝나는 시점에 실행하도록 한다． 이후， 나중의 결과에서 처음의 결과를 빼게 되면， 해당 기간동안의 값이 나타나게 된다． 이들 보고서의 내용을 파일로 받아， 원하는 값들을 일치시키는 것이 간편한 방법이 될 것이다． vmstat 의 s, f, Drives 옵션에 의해 생성되는 나머지 필드들은 인퍼익스플러러와 튜닝가이드에 잘 설명되어 있다．
